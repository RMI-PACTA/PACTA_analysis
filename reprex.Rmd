---
title: "Running the web tool: A reproducible example"
date: "`r Sys.Date()`"
output: github_document
---

## Introduction

This document aims to provide a reproducible example of how to run the web tool that PACTA_analysis provides. It is based on [these instructions by Jacob](https://bit.ly/2RCRJn7). Here are some of the ways you may use this document:

* To document the repository, by incorporating it into the README file.
* To onboard contributors.
* To test the output of PACTA_analysis remains unchanged, maybe by running this document on a continuous integration service like GitHub actions.

## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE
)
```

### Dependencies

This report uses the following packages:

```{r}
library(testthat)
library(glue)
library(config)
library(rlang)
library(here)
library(renv)
library(fs)
library(tidyverse)
library(devtools)
```

These are all the packages detected in the PACTA_analysis project:

```{r}
pkg <- renv::dependencies()
sort(unique(pkg$Package))
```

The published [README](https://github.com/2DegreesInvesting/PACTA_analysis#system-requirements) suggest this project has a number of additional dependencies. That information seems quite restrictive and outdated.

<details>

<summary>Here is the information for this session</summary>

```{r}
devtools::session_info()
```

</details>

### Required data 

Ensure the example data is available.

```{r}
file_name <- "TestPortfolio_Input.csv"
example_dataset <- here("sample_files", "20_input_files", file_name)

expect_true(file_exists(example_dataset))
```

Ensure the example data is copied into the expected directory.

```{r}
expected_dataset <- here("working_dir", "20_Raw_Inputs", file_name)

if (file_exists(expected_dataset)) {
  warn(glue("Removing existing file: {expected_dataset}"))
  file_delete(expected_dataset)
}

file_copy(example_dataset, expected_dataset)

expect_true(file_exists(expected_dataset))
```

### Required files-system structure

If they don't already exist, create the required directories.

```{r}
create_directory_if_it_doesnt_exist <- function(directory) {
  if (!fs::dir_exists(directory)) {
    fs::dir_create(directory)
  }
  
  invisible(directory)
}

children <- c("30_Processed_Inputs", "40_Results", "50_Outputs")
(paths <- here("working_dir", children))

walk(paths, create_directory_if_it_doesnt_exist)
```

Ensure the following repos are siblings of PACTA\_analysis/ (

* 2DegreesInvesting/pacta-data
* 2DegreesInvesting/create_interactive_report
* 2DegreesInvesting/PACTA_analysis

```{r}
is_sibling <- function(x) {
  parent <- path_dir(here())
  dir_exists(path(parent, x))
}

repos <- c("pacta-data", "create_interactive_report", "PACTA_analysis")
all_siblings <- all(map_lgl(repos, is_sibling))

expect_true(all_siblings)
```

Ensure the repo PACTA_analysis is on the branch `current_web_functionality`, or a PR off it. This is not a test but a visual inspection.

Ensure you are on the required working directory.

```{r}
expect_equal(path_file(here()), "PACTA_analysis")
```

TODO: The branch `current_web_functionaliry` is long-lived, which makes the workflow more complex than the standard GitHub workflow (by which the only long-lived branch is `master`). I suggest merging `current_web_functionality` into master, or extracting the non-overlapping code into a separate repo.

### Ensure the value of `portfolio_name_ref_all` is "TestPortfolio_Input"

Ensure `portfolio_name_ref_all` takes the value "TestPortfolio_Input" in the files which name contains "web\_tool\_scripts".

```{r}
# What value is currently assigned to the variable `portfolio_name_ref_all`?
show_pattern_in_file <- function(file, pattern) {
  grep(pattern, readLines(file), value = TRUE)
}

(files <- dir_ls(regexp = "web_tool_script"))

this_pattern <- "portfolio_name_ref_all.*<-"
matched <- map(files, show_pattern_in_file, pattern = this_pattern)
walk(matched, writeLines)

script_has_this_pattern <- grepl(this_pattern, matched)
expect_true(all(script_has_this_pattern))
```

TODO: If the value of `portfolio_name_ref_all` comes from the user, we need an interface for the user to supply it -- instead of asking a user to change the source code.

### 3 Configuration files

Ensure the file "TestPortfolio\_Input\_PortfolioParameters.yml" exists.

```{r}
config_1 <- here(
  "working_dir", 
  "10_Parameter_File", 
  "TestPortfolio_Input_PortfolioParameters.yml"
)

look_into <- function(path, n = -1L) {
  lines <- readLines(path, n, encoding = "UTF-8")
  writeLines(lines)
}

look_into(config_1)

expect_true(file_exists(config_1))
```

Ensure this other configuration file also exists, and has correct paths:

```{r}
config_2 <- here("parameter_files", "WebParameters_2dii.yml")
look_into(config_2)
```

```{r}
expect_true(file_exists(config_2))
```

Make the configuration file portable, so it works locally and on GitHub actions.

```{r}
make_config_portable <- function(config) {
  lines <- readLines(config, encoding = "UTF-8")
  lines <- make_paths_portable(lines)
  writeLines(lines, config)
  
  invisible(config)
}

make_paths_portable <- function(x) {
  x <- replace_field(x, "project_location_ext", pattern = "PACTA_analysis")
  x <- replace_field(x, "data_location_ext", pattern = "pacta-data")
  x <- replace_field(x, "template_location", pattern = "create_interactive_report")
  x
}

replace_field <- function(x, field, pattern) {
  parent <- path_dir(here())
  value <- path(parent, extract_from(x, pattern))
  sub(glue("({field}:[ ]?).*"), glue("\\1{value}"), x)
}

extract_from <- function(x, pattern) {
  line <- grep(pattern, x, value = TRUE)
  sub(glue(".*({pattern}.*)"), "\\1", line)
}
```

```{r}
make_config_portable(config_2)
config_paths <- config::get(file = config_2)$paths
str(config_paths)

all_paths_exist <- all(map_lgl(config_paths, dir_exists))
expect_true(all_paths_exist)
```

TODO: It would be nice to set these paths from a more flexible interface, like the arguments of a function or the parameters of a parametrized rmarkdown file.

### Run scripts

```{r, error=TRUE, message=FALSE}
# Populate the directory "working\_dir/30\_Processed\_Inputs/"
source("web_tool_script_1.R")

#  Populate working_dir/40_Results/
source("web_tool_script_2.R")

# Feed previous results plus data from the pacta-data/ into
# `create_interactive_report()`.
source("web_tool_script_3.R") 
```

Ensure the directory "working\_dir/50\_Outputs/" is now populated with some .css file, some .js file, the file "index.html", and some .zip file.

```{r}
outputs <- path("working_dir", "50_Outputs")

css <- dir_ls(outputs, recurse = TRUE, regexp = "[.]css")
expect_true(length(css) > 0L)

js <- dir_ls(outputs, recurse = TRUE, regexp = "[.]js")
expect_true(length(js) > 0L)

index <- dir_ls(outputs, recurse = TRUE, regexp = "index[.]html")
expect_true(length(index) > 0L)

zip <- dir_ls(outputs, recurse = TRUE, regexp = "[.]zip")
expect_true(length(zip) > 0L)
```

The output looks good!

```{r}
look_into(index, n = 20L)
```

```{r}
dir_tree(path(outputs, "TestPortfolio_Input"), recurse = FALSE)
```

NOTES

* Some warnings may be avoided if required directories are created only if they don't already exist.

```r
Warning message:
In read_file(paste0(file_location, "/fund_data.fst")) :
  ~/git/pacta-data/2019Q4/cleaned_files/fund_data.fst does not exist
```

* I'm not sure if this dataset is crucial, but it's missing from my clone of pacta-data/:

```{r}
dir_ls(path("..", "pacta-data", "2019Q4", "cleaned_files"))
```

* I see duplicated code in the first lines of each script. For example, you may extract all calls to `library()` into a file packages.R; and you may also extract the repeated definitions of `working_location` (which I think should be `working_location <- here()`).

